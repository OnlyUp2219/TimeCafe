# Email Confirmation & Auth Flow Checklist

## Основные политики
- RequireUniqueEmail = true
- RequireConfirmedAccount = true
- JWT и доступ к защищённым endpoint'ам только после EmailConfirmed = true

## Регистрация
- Создание пользователя сразу (EmailConfirmed = false)
- Отправка письма подтверждения немедленно
- Ответ API: не раскрывать существование email (унифицированно)

## Логин
- Неверный пароль / нет пользователя / неподтверждённый email → единый ответ (Invalid credentials)
- Верный пароль + EmailConfirmed = false → вернуть специальный код/флаг; фронт редиректит на /email-pending
- Никаких деталей для злоумышленника (нет enumeration)

## Страница /email-pending
- Текст: “Письмо отправлено”
- Кнопка resend (disabled до таймера)
- Отображение времени до следующей попытки
- Сообщение “Если письмо не пришло — проверьте спам”

## Resend Confirmation
- Endpoint: POST /resend-confirmation
- Вход: email (или userId после успешного ввода пароля)
- Ответ всегда: “Если аккаунт существует — письмо отправлено”
- Throttle: min interval (например, 120 сек)
- Суточный лимит (например, 5)
- Логи: timestamp, user/email, IP
- Возможная капча после превышения лимита

## External Login (Google / Microsoft)
- Найти пользователя по email
  - Если найден и EmailConfirmed = false → установить EmailConfirmed = true + привязать login
  - Если найден и Confirmed → привязать login (если отсутствует)
  - Если не найден → создать Confirmed + роль по умолчанию
- Не создавать второго пользователя
- ProviderKey проверять на коллизию

## Очистка неподтверждённых (подумаю позже)
- Фоновая задача: удалить EmailConfirmed = false старше 30 дней
- До удаления (опционально) — отправить напоминание (одно письмо)

## Rate Limiting / Anti-abuse (минимум)
- Единый сервис категорий (позже): resend_email_confirm, password_reset, sms_verify
- Сейчас: простой throttle (RateLimiter) + счётчик попыток (как в SMS)
- Redis переход при масштабировании
- Логирование превышений

## Безопасность токенов
- Email confirmation token TTL: 30–120 минут
- Одноразовость подтверждения
- Refresh token хранить в httpOnly cookie (рекомендация)
- Rotate refresh на каждом обновлении (рекомендация)

## Интерсептор 401 (Frontend)
- Refresh только если исходный запрос имел Authorization
- Игнорировать 401 от публичных/gостевых endpoint'ов
- Очередь ожидания при массовых 401 (опционально)
- Если refresh невалиден → logout + редирект на /login

## Password Reset
- Разрешать только если EmailConfirmed = true
- Ответ на несуществующий email — единый

## Логи и аудит
- Регистрация: userId, email, ip
- Подтверждение: timestamp, способ (email link / external)
- Resend: user/email, ip, попытка №
- External attach: provider, providerKey

## Возможные расширения (позже)
- Pending-flow вместо немедленного создания
- MFA после подтверждения
- Device fingerprint / подозрительные входы
- Unified SecurityThrottle сервис
- Нотификация об очистке неподтверждённых аккаунтов
- Верификация смены email (двойное подтверждение)

## Порядок внедрения (итеративно)
1. Включить RequireUniqueEmail + RequireConfirmedAccount
2. Страница /email-pending + resend endpoint
3. External login апгрейд существующего неподтверждённого
4. Throttle resend + логирование
5. Очистка неподтверждённых (задача)
6. Ужесточение интерсептора (см. TODO)
7. Перенос refresh токена в httpOnly cookie (если ещё не)
8. Расширение на централизованный throttle

## TODO: Аудит refresh interceptor
Минимальная реализация выполнена: отключен авто-refresh для публичных эндпоинтов и запросов без Authorization.