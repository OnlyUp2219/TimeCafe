# Архитектура интеграционных тестов для Endpoints

## Общие принципы

- Тестируем только актуальные endpoint-ы, игнорируем легаси-код.
- Каждый endpoint или группа endpoint-ов — отдельный класс тестов.
- Внутри класса — методы для разных сценариев: успешные, edge-case, негативные.

## Структура папок

```
Integration/
  Endpoints/
    UserEndpointsTests.cs
    PermissionsEndpointsTests.cs
  Helpers/
    TestDataFactory.cs
    AuthHelper.cs
  Fixtures/
    TestServerFixture.cs
```

## Типы тестов

- **Интеграционные**: проверяют работу endpoint-а с реальными зависимостями (БД, авторизация).
- **Edge-case**: тестируют граничные и нестандартные входные данные.
- **Негативные**: проверяют корректную обработку ошибочных запросов и отсутствие неожиданных изменений.

## Критерии успешности

- Ожидаемый HTTP-статус (200, 201, 400, 403, 404 и т.д.).
- Корректное содержимое ответа.
- Система остается в консистентном состоянии.
- Нет неожиданных ошибок или исключений.

## Архитектура классов

Классы тестов рекомендуется называть по области или функционалу, например:

- `UserTests`
- `PermissionsTests`

Для методов использовать нейминг вида `[ТипКомпонента]_[Действие]_Should_Return[ОжидаемыйРезультат]_When[Условие/Сценарий]`, например:

- `Endpoint_GetUser_Should_Return200_WhenUserExists`
- `Handler_CreateUser_Should_Return400_WhenDataIsInvalid`
- `Repository_DeleteUser_Should_Return403_WhenNoPermission`
- `Service_Role_Should_ThrowException_WhenDependencyFails`

Такой подход применим для endpoint-ов, handler-ов, сервисов и других компонентов.

## Фикстуры и инфраструктура

- Используется общий тестовый сервер (`WebApplicationFactory`).
- Для изоляции данных — отдельная тестовая БД, очистка/миграция перед каждым тестом.
- Фикстуры для подготовки тестовых данных (создание пользователя, ролей).

## Повторное использование кода

- Вспомогательные методы для авторизации, отправки запросов, генерации данных.
- Базовые классы или интерфейсы для общих сценариев.

## Полезные соглашения и примеры

- **BaseEndpointTest**: рекомендуется иметь базовый класс тестов `BaseEndpointTest`, который предоставляет `Client`, `Factory` и методы для подготовки данных (например, `SeedUser`). Это позволяет уменьшить дублирование в тестах и централизовать конфигурацию тестового сервера.
- **Глобальные using**: в проекте тестов удобно использовать `global using FluentAssertions;` чтобы писать компактные и выразительные утверждения.
- **Шаблон теста (AAA)**: тесты должны следовать Arrange / Act / Assert. Пример структуры:
  - Arrange: подготовка входных данных и предварительное состояние.
  - Act: вызов endpoint-а через `Client`.
  - Assert: проверки результата.
- **Логирование ошибок в тестах**: при ассертах оборачивайте проверки в `try/catch` и логируйте тело ответа для быстрого дебага, например:

```csharp
try
{
    response.StatusCode.Should().Be(HttpStatusCode.OK);
    var json = JsonDocument.Parse(jsonString).RootElement;
    json.TryGetProperty("revoked", out var revoked).Should().BeTrue();
}
catch (Exception)
{
    Console.WriteLine($"[Logout_Should_ReturnOk_WhenTokenIsBase64ButNonexistent] Response: {jsonString}");
    throw;
}
```

## Итог

- Архитектура тестов проста для понимания и масштабирования.
- Каждый тест независим, легко поддерживать и расширять.
- Вся инфраструктура и вспомогательные методы вынесены в отдельные классы.
